# Helper functions and utilities
#
# This file contains small functions that come in handy in several
# places, or are a bit too general to put in other scripts.
#

#' Expit function
#'
#' @description Takes the inverse of the log odds to return a probability.
#'
#' @param x A number (preferably a log-odds)
#' @return A probability.
#' @export


expit <- function(x) exp(x)/(1+exp(x))

logit <- function(p)log(p/(1-p))

or_func <- function(risk1, risk0) risk1*(1-risk0)/(risk0*(1-risk1))
#' The Bernoulli distribution
#'
#' @description Random generation for the Bernoulli distribution with parameters `prob`
#'
#' @param n number of observations
#' @param prob probability of success on each trial
#' @return vector of length n
#' @export

rbern <- function(n, prob) rbinom(n, 1, prob)

## Read in individual datasets
read_chunked <- function(filepat){
  last_folder <- dplyr::last(list.files(path = "./data/simulations", full.names = T))
  all_sims <- list.files(path = paste0(last_folder, "/parts"), pattern = filepat, full.names = T)
  is <- stringr::str_extract(all_sims, "\\d+(?=[/\\d]*\\.)")
  purrr::map2_dfr(
    all_sims,
    is,
    function(nm, i) {
      readRDS(nm) %>%
        as_tibble() %>%
        dplyr::mutate(sim = i)}
  )
}


## Wrappers for balancing intercepts.
gen_pr_a_wrapper <- function(w, awcoef){
  x <- w*awcoef
  x <- replace(x, is.nan(x), 0)
  function(alpha0) plogis(alpha0[1] + x)   # probability generated by model at given intercept value
}

gen_pr_y_wrapper <- function(w, wycoef, a, aycoef){
  function(alpha0) plogis(alpha0[1] + wycoef[1]*w + aycoef[1]*a)   # probability generated by model at given intercept value
}


effect_measures <- function(settings, measure = "rr"){
  if (measure == "rr") {
    settings %>%
      dplyr::transmute(
        measure = measure,
        label,
        pw,
        effect,
        delta,
        effw0 = exp(delta),
        effw1 = exp(delta + eta),
        ## Probability of Y(a=0)
        py0w1 = exp(yint + wycoef), # for W=1
        py0w0 = exp(yint), # for W=0
        ## Probability of Y(a=1)
        py1w1 = exp(yint + wycoef + delta + eta), # for W = 1
        py1w0 = exp(yint + delta), # For W = 0

        ## Probability of Y standardized to distribution of W for ATE
        py0 = pw*py0w1 + (1-pw)*py0w0, ## under no treatment
        py1 = pw*py1w1 + (1-pw)*py1w0, ## under treatment

        ## Probabilities of W given A (distribution of W in treated)
        pw1a1 = pa_w1*pw/pa,
        pw0a1 = pa_w0*(1-pw)/pa,
        ## Probability of Y standardized to W in the treated
        py0a1 = pw1a1*py0w1 + (pw0a1)*py0w0,
        py1a1 = pw1a1*py1w1 + (pw0a1)*py1w0,

        ## ATE risk ratio and odds ratio
        ate = py1/py0,

        ## ATT risk ratio and odds ratio
        att = py1a1/py0a1,
      )
  } else {
    settings %>%
      dplyr::transmute(
        measure = measure,
        label,
        effect,
        delta,
        pw,
        effw0 = exp(delta),
        effw1 = exp(delta + eta),
        ## Probability of Y(a=0)
        py0w1 = expit(yint + wycoef), # for W=1
        py0w0 = expit(yint), # for W=0
        ## Probability of Y(a=1)
        py1w1 = expit(yint + wycoef + delta + eta), # for W = 1
        py1w0 = expit(yint + delta), # For W = 0

        ## Stratum-specific ORs
        orw1 = py1w1*(1-py0w1)/(py0w1*(1-py1w1)),
        orw0 = py1w0*(1-py0w0)/(py0w0*(1-py1w0)),

        ## Probability of Y standardized to distribution of W for ATE
        py0 = pw*py0w1 + (1-pw)*py0w0, ## under no treatment
        py1 = pw*py1w1 + (1-pw)*py1w0, ## under treatment

        ## Probabilities of W given A (distribution of W in treated)
        pw1a1 = pa_w1*pw/pa,
        pw0a1 = pa_w0*(1-pw)/pa,
        ## Probability of Y standardized to W in the treated
        py0a1 = pw1a1*py0w1 + (pw0a1)*py0w0,
        py1a1 = pw1a1*py1w1 + (pw0a1)*py1w0,

        ## ATE odds ratio
        ate = py1*(1-py0)/(py0*(1-py1)),

        ## odds ratio
        att = py1a1*(1-py0a1)/(py0a1*(1-py1a1)),
      )
  }
}
